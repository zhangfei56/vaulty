# 数据存储优化方案

## 问题分析

根据 StatsPage.tsx 的使用场景，发现当前数据存储策略存在以下问题：

### 当前数据需求
1. **appUsageStats** - 按时间范围（日/周/月）的应用使用统计
2. **hourlyStats** - 指定日期的每小时使用统计
3. **dailyTopApps** - 指定日期的应用使用排行

### 存在的问题
1. **数据来源不一致**：appUsageStats 来自聚合表，hourlyStats 来自原始事件实时计算
2. **性能问题**：每小时统计每次都要从原始事件实时计算，数据量大时性能差
3. **数据冗余**：同时存储原始事件和聚合会话记录，占用更多存储空间

## 优化方案：分层存储 + 预聚合

### 1. 数据分层策略

#### 原始事件层（短期存储）
- **表名**：`app_usage_raw_events`
- **保留时间**：30天
- **用途**：
  - 数据完整性保证
  - 支持数据修正和重新计算
  - 生成聚合数据的数据源

#### 会话记录层（长期存储）
- **表名**：`app_usage_records`
- **保留时间**：长期保存
- **用途**：
  - 支持按时间范围的统计查询
  - 生成应用使用排行

#### 小时统计层（中期存储）
- **表名**：`app_usage_hourly_stats`（新增）
- **保留时间**：90天
- **用途**：
  - 快速查询每小时使用统计
  - 预聚合数据，提高查询性能

### 2. 数据流程优化

#### 同步流程
```
1. 从Android获取原始事件数据
2. 保存到原始事件表
3. 处理生成会话记录，保存到会话记录表
4. 按日期聚合生成小时统计数据（新增）
5. 更新同步时间
```

#### 查询流程
```
- appUsageStats: 从会话记录表查询
- hourlyStats: 优先从小时统计表查询，如果没有则从原始事件计算
- dailyTopApps: 从会话记录表查询
```

### 3. 核心改进

#### 新增实体
- `AppUsageHourlyStats`：存储预聚合的每小时统计数据
- `AppUsageHourlyStatsRepository`：管理小时统计数据的CRUD操作

#### 优化的查询策略
```typescript
async getHourlyUsageStats(date: string): Promise<HourlyUsageStat[]> {
  // 1. 优先从聚合表查询
  const aggregatedStats = await this.hourlyStatsRepository.getHourlyUsageStats(date);
  
  if (hasData) {
    return aggregatedStats; // 快速返回
  }
  
  // 2. 如果聚合表没有数据，从原始事件计算
  const rawStats = await this.rawEventRepository.getHourlyUsageStats(date);
  
  // 3. 同时聚合保存到聚合表，下次查询更快
  await this.hourlyStatsRepository.aggregateHourlyStats(date);
  
  return rawStats;
}
```

#### 数据维护策略
```typescript
async performDataMaintenance(): Promise<MaintenanceResult> {
  // 清理过期的原始事件数据（保留30天）
  await this.cleanupOldRawEvents(30);
  
  // 清理过期的小时统计数据（保留90天）
  await this.cleanupOldHourlyStats(90);
  
  // 清理过期的已删除应用记录（保留30天）
  await this.cleanupDeletedApps(30);
}
```

## 方案优势

### 1. 性能提升
- **小时统计查询**：从 O(n) 实时计算 → O(1) 直接查询
- **减少计算开销**：预聚合数据，避免重复计算
- **索引优化**：针对聚合表建立合适的索引

### 2. 存储优化
- **分层存储**：不同类型数据有不同保留期限
- **自动清理**：定期清理过期数据，控制存储空间
- **按需聚合**：只在需要时才聚合数据

### 3. 数据一致性
- **统一数据源**：所有聚合数据都来自原始事件
- **事务保证**：聚合操作在事务中完成
- **容错处理**：如果聚合失败，可以从原始事件重新计算

### 4. 可维护性
- **清晰的数据流**：原始事件 → 会话记录 → 小时统计
- **灵活的查询**：支持实时计算和预聚合查询
- **定期维护**：自动化的数据清理和优化

## 使用建议

### 1. 部署策略
- 渐进式部署：先部署新的聚合逻辑，再逐步迁移查询
- 数据兼容：保持现有查询接口不变，内部优化实现

### 2. 监控指标
- 查询性能：监控每小时统计查询的响应时间
- 存储空间：监控各层数据的存储占用
- 聚合效率：监控聚合操作的成功率和耗时

### 3. 维护计划
- 建议每周执行一次数据维护
- 可以设置定时任务自动执行
- 在低峰期执行，避免影响用户体验

## 总结

通过引入分层存储和预聚合策略，我们解决了以下问题：

1. ✅ **性能问题**：小时统计查询从实时计算变为直接查询
2. ✅ **数据一致性**：所有统计数据都有统一的数据源和生成流程
3. ✅ **存储优化**：通过分层保留和自动清理，合理控制存储空间
4. ✅ **可维护性**：清晰的数据流和自动化维护机制

这个方案既保证了查询性能，又维持了数据的完整性和一致性，是一个平衡性能和存储的最优解决方案。 